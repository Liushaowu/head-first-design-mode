# 设计模式



## 为什么要学设计模式？

设计模式可以把思考架构的层次提高到模式层面，而不是仅停留在琐碎的对象上。 —《Head First 设计模式》

设计模式可以让你和其他开发人员之间有共享词汇，一旦懂了这些词汇，和其他开发人员沟通起来就很容易。 —《Head First 设计模式》



**设计模式的定义**：在某种**情境**下，针对某**问题**的某种**解决方案**



### OO设计原则 （Object Oriented 面向对象）

- 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的混在一起
- 针对接口编程 而不是针对实现
- 为了交互对象之间的松耦合设计而努力。
- 合成复用原则（多用组合 少用继承）
- 好莱坞原则：不要给我们打电话，我们会给你打电话
- **单一职责 ：一个类应该只有一个引起变化的原因**
- **开放关闭原则：对修改关闭 对拓展开放**
- **依赖倒置原则：依赖抽象，不要依赖具体的类**
- **最少知识原则(迪米特法则)：只和朋友交谈**
- **~~里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能。~~**
- **接口隔离原则(Interface Segregation Principle)：使用多个隔离的接口，比使用单个接口更好。**



### 分类：设计模式分为三大类

- **创建型 ：提供一个方法 用来创建对象**
  - 单例模式(Singleton)
  - 工厂方法模式(Factory Method)
  - 抽象工厂模式(Abstract Factory)
  - ~~原型模式(Prototype)~~
  - ~~建造者模式(Builder)~~
- **行为形 ：类和对象如何交互以及分配指责**
  - 策略模式(Strategy)
  - 观察者模式(Observer)
  - 命令模式(Command)
  - 模板方法模式(Template Method)
  - 迭代器模式(iterator)
  - 状态模式(State)
  - ~~访问者模式(Visitor)~~
  - ~~中介者模式(Mediator)~~
  - ~~解释者模式(Interpreter)~~
  - ~~责任链模式(Chain of Responsibility)~~
  - ~~备忘录模式(Memento)~~
- **结构型 ：把类或者对象组合到更大的结构中**
  - 装饰者模式(Decorator)
  - 组合模式(Composite)
  - 外观模式(Facade)
  - 适配器模式(Adapter )
  - 代理模式(Proxy)
  - ~~享元模式(Flyweight)~~
  - ~~桥接模式(Bridge )~~





# 创建型



## 	单例模式

​		**定义：确保程序中一个类最多只有一个实例 并提供访问这个实例的全局点**

- 在Java 中实现单间模式需要私有的构造器、一个静态方法和一个静态变量
- 确定在性能和资源上的限制然后小心的选择适当的方案实现单件，以解决多线程的问题(我们必须认定所有的程序都是多线程的)
- 小心如果使用多个类加载器，可能导致单件失效而产生多个实例
- 如果是用JVM1.2或之前的版本，以免垃圾回收器将单例回收 必须建立单例注册表

![image-20211029101426362](D:\Desktop\设计模式\单例模式.png)



## 	工厂模式

1. 所有工厂都会用来封装对象的创建

2. 所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合

3. 工厂是很有威力的技巧，帮助我们针对抽象变成，而不是具体的类编程



- ### 简单工厂

1. 虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类解耦。



- ### 工厂方法

  **定义：使用继承把对象的创建委托给子类，子类实现工厂方法来创建对象**

1. 工厂方法允许类将实例化延迟到子类进行

![工厂方法模式](D:\Desktop\设计模式\工厂方法模式.jpg)

- ### 抽象工厂

  **定义：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体的类**

1. 抽象工厂创建相关的对象家族而不需要依赖他们具体的类

![image-20211029100810076](D:\Desktop\设计模式\抽象工厂.png)

# 行为型



## 	策略模式

​		**定义：定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变法独立于使用算法的客户**

![image-20211029105619802](D:\Desktop\设计模式\策略模式.png)



## 		观察者模式

​		**定义：定义了对象之间的一对多依赖，这儿样依赖，当一个对象改变状态时，它的所有依赖者都会受到通知并自动更新**

- 主题(也就是可观察者)用一个共同的接口来更新观察者
- 观察者和可观察者之间松耦合方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口
- 使用此模式，你可从被观察者处推(push) 或(pull) 数据 (然而 推的方式被认为更正确)
- 有多个观察者时，不可以依赖特定的通知次序
- Java有多各种观察者模式的实现，包括通用的java.util.Observable (不够灵活，有必要自己实现该模式会更灵活)
- 此模式也被应用在很多地方，例如 JavaBeans、RMI;

![image-20211029110821635](D:\Desktop\设计模式\观察者模式.png)





## 	命令模式

​		**定义：将“请求”封装成对象，一遍使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作**	

- 命令模式将发出请求的对象和执行请求的对象解耦
- 在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接受者和一个或一组动作。
- 调用者通过调用命令对象的execute()发出请求。这会使得接收者的动作被调用。
- 调用者可以接受命令当做参数，甚至在运行时动态进行
- 命令可以支持撤销，做法是实现一个undo()方法来回到execute()被执行前的状态
- 宏命令 是命令的一种简单延伸，允许调用多个命令，宏方法也可以支持撤销。
- 实际操作中，很常见使用“聪明”命令的对象，也就是直接实现了请求，而不是将工作委托给接收者
- 命令也可以用来实现日志和事务系统

![image-20211029114118829](D:\Desktop\设计模式\命令模式.png)



## 	模板方法

​		**定义： 在一个方法中定义一个算法的骨架，而将一席而不周延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤**

 - “模板方法” 模式为我们提供了一种代码复用的重要技巧
 - 模板方法的抽象类可以定义具体方法、抽象方法和钩子
 - 抽象方法由子类实现
 - 钩子是一种方法，他在抽象类中不做事，或者只做默认的事，子类可以选择要不要去覆盖它
 - 为了防止子类改变模板方法中的算法，可以将模板方法声明为final
 - 好莱坞原则告诉我们，将决策权放在高层模块中，以便决定如何以及何时调低层模块。
 - 策略模式和模板方法模式都是封装算法，一个用来组合，一个用来继承
 - 工厂方法是模板方法的一个特殊版本

![image-20211029131030965](D:\Desktop\设计模式\模板方法.png)



## 	迭代器模式

​		**定义：提供一种方法顺序访问一个聚合的对象中的各个元素，而又不暴露其内部的表示**

		- 迭代器将遍历聚合的工作封装进了一个对象中
		- 当使用迭代器的时候，我们一来聚合提供遍历
		- 迭代器提供了一个通用的接口，然后我们编码使用聚合项时，就可以使用多态机制
		- 我们应该努力让一个类 只分配一个责任

![image-20211029132209343](D:\Desktop\设计模式\迭代器模式.png)



## 	状态模式

​		**定义：允许对象在内部状态改变它的行为，对象看起来好像修改了它的类**

- 状态模式允许一个对象基于内部状态而拥有不同行为
- Context会将行为委托给当前状态对象。
- 通过每个状态封装进一个类，我们以后需要做的任何改变局部化了
- 状态模式和策略模式有相同的类图，但是它们的意图不同
- 策略模式通常会用行为或算法来配置Context类
- 状态模式允许Context随着状态的改变而改变行为
- 状态转换可以由State类或Context类控制
- 使用状态模式通常会导致设计中类数目大量增加
- 状态类可以被多个Context实力共享

![image-20211029133034101](D:\Desktop\设计模式\状态模式.png)



# 结构形



## 	装饰者模式

​		**定义：动态的将责任附加到对象上。想要拓展功能，装饰者提供有别于继承的另一种选择**

- 继承属于拓展形式，但不见得是达到弹性设计的最佳方式

- 在我们的设计中，应该允许行为可以被拓展，而无需修改现有的代码

- 组合和委托可用于运行时动态加上新的行为

- 处理继承，装饰者模式也可以让我们拓展行为

- 装饰者模式意味着一群装饰者类，这些类用来包装具体组件

- 装饰者类反映出被装饰的组件类型（事实上，他们具有相同的类型，都经过接口或继承实现）。

- 装饰者可以在被装饰者的行为前面与 / 或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。

- 你可以用无数个装饰者包装一个组件。

- 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。

- 装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。

- ![image-20211029113649148](D:\Desktop\设计模式\装饰者模式.png)

  

  ## 适配器

​	**定义：将一个类的接口，转换成客户期望的另一个接口。适配器让原来接口不兼容的类可以合作无间**

 - 当需要使用一个现有的类而其接口并不符合你的需求时，就是用适配器
 - 适配器改变接口以符合客户的期望
 - 实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小和复杂度而定
 - 适配器有两种形式，对象适配器和类适配器。类适配器需要用到多重继承
 - 适配器将一个对象包装以改变其接口；装饰者将一个对象包装起来以增加新的行为和责任，而外观将一群对象包装起来以简化其接口

![image-20211029115013586](D:\Desktop\设计模式\适配器模式.png)



## 	外观模式

​	**定义：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用**

- 当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观
- 外观将客户从一个复杂的子系统中解耦
- 实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行
- 你可以为一个子系统实现一个以上的外观

![image-20211029120025648](D:\Desktop\设计模式\外观模式.png)



## 	组合模式

​		**定义：提供一个结构，可同时包容个别对象和组合对象**

- 组合模式允许客户对个别对象和组合对象一视同仁

- 组合结构内的任意对象成为组件，组件可以是组合，也可以是叶节点

- 在实现组合模式时，有许多设计上的这种。你要根据需要平衡透明性和安全性。

   ![image-20211029132811905](D:\Desktop\设计模式\组合模式.png)

## 	代理模式

​	**定义：代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问**

- 管理访问的方式有很多种
- 远程代理管理客户与远程对象之间的交互
- 虚拟代理控制访问实例化开销大的对象
- 保护代理基于调用者控制对象方法的访问
- 代理模式有很多变体，例如：缓存代理、同步代理、防火墙代理和写入时复制代理
- 代理在结构上类似于装饰着，但是目的不同
- 装饰者模式对对象加上行为，而代理则是控制访问
- Java内置的代理支持，可以根据需要建立动态代理，并将所有调用分配到所选的处理器
- 就和其他的包装者一样，代理会造成设计中类的数据增加。

![image-20211029133651307](D:\Desktop\设计模式\一般代理.png)



远程代理

虚拟代理

保护代理

![image-20211029134154256](D:\Desktop\设计模式\保护代理.png)



